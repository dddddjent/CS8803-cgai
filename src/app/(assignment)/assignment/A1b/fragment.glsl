/////////////////////////////////////////////////////
//// CS 8803/4803 CGAI: Computer Graphics in AI Era
//// Assignment 1B: Neural SDF
/////////////////////////////////////////////////////

precision
highp float; //// set default precision of float variables to high precision

varying vec2 vUv; //// screen uv coordinates (varying, from vertex shader)
uniform vec2 iResolution; //// screen resolution (uniform, from CPU)
uniform float iTime; //// time elapsed (uniform, from CPU)

#define PI 3.1415925359

const vec3 CAM_POS = vec3(0, 1, 0);

vec3 rotate(vec3 p, vec3 ax, float ro) {
    return mix(dot(p, ax) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);
}

/////////////////////////////////////////////////////
//// sdf functions
/////////////////////////////////////////////////////

float sdfPlane(vec3 p, float h) {
    return p.y - h;
}

float sdfBunny(vec3 p) {
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 2. + PI / 1.);

    // sdf is undefined outside the unit sphere, uncomment to witness the
    // abominations
    if (length(p) > 1.0) {
        return length(p) - 0.9;
    }

    //// neural network weights for the bunny

    vec4 f0_0 =
        sin(p.y * vec4(1.74, -2.67, 1.91, -1.93) +
                p.z * vec4(2.15, -3.05, .50, -1.32) +
                p.x * vec4(2.47, .30, -2.00, -2.75) + vec4(1.31, 6.89, -8.25, .15));
    vec4 f0_1 =
        sin(p.y * vec4(-.72, -3.13, 4.36, -3.50) +
                p.z * vec4(3.39, 3.58, -4.52, -1.10) +
                p.x * vec4(-1.02, -2.90, 2.23, -.62) + vec4(1.61, -.84, -2.00, -.47));
    vec4 f0_2 = sin(
            p.y * vec4(-1.47, .32, -.70, -1.51) + p.z * vec4(.17, .75, 3.59, 4.05) +
                p.x * vec4(-3.10, 1.40, 4.72, 2.90) + vec4(-6.76, -6.43, 2.41, -.66));
    vec4 f0_3 =
        sin(p.y * vec4(-2.75, 1.59, 3.43, -3.39) +
                p.z * vec4(4.09, 4.09, -2.34, 1.23) +
                p.x * vec4(1.07, .65, -.18, -3.46) + vec4(-5.09, .73, 3.06, 3.35));
    vec4 f1_0 = sin(mat4(.47, .12, -.23, -.04, .48, .06, -.24, .19, .12, .72,
                -.08, .39, .37, -.14, -.01, .06) *
                f0_0 +
                mat4(-.62, -.40, -.81, -.30, -.34, .08, .26, .37, -.16, .38,
                    -.09, .36, .02, -.50, .34, -.38) *
                    f0_1 +
                mat4(-.26, -.51, -.32, .32, -.67, .35, -.43, .93, .12, .34,
                    .07, -.01, .67, .27, .43, -.02) *
                    f0_2 +
                mat4(.02, -.18, -.15, -.10, .47, -.07, .82, -.46, .18, .44,
                    .39, -.94, -.20, -.28, -.20, .29) *
                    f0_3 +
                vec4(-.09, -3.49, 2.17, -1.45)) /
            1.0 +
            f0_0;
    vec4 f1_1 = sin(mat4(-.46, -.33, -.85, -.57, .41, .87, .25, .58, -.47, .16,
                -.14, -.06, -.70, -.82, -.20, .47) *
                f0_0 +
                mat4(-.15, -.73, -.46, -.58, -.54, -.34, -.02, .12, .55, .32,
                    .22, -.87, -.57, -.28, -.51, .10) *
                    f0_1 +
                mat4(.75, 1.06, -.08, -.17, -.43, .69, 1.07, .23, .46, -.02,
                    .10, -.11, .21, -.70, -.08, -.48) *
                    f0_2 +
                mat4(.04, -.09, -.51, -.06, 1.12, -.21, -.35, -.17, -.95, .49,
                    .22, .99, .62, -.25, .06, -.20) *
                    f0_3 +
                vec4(-.61, 2.91, -.17, .71)) /
            1.0 +
            f0_1;
    vec4 f1_2 = sin(mat4(.01, -.86, -.07, .46, .73, -.28, .83, .12, .16, .33, .28,
                -.55, -.21, -.02, .53, -.15) *
                f0_0 +
                mat4(-.28, -.32, .19, -.28, .24, -.23, -.61, -.39, .26, .40,
                    .18, .41, .21, .57, -.91, -.29) *
                    f0_1 +
                mat4(.23, -.40, -1.34, -.50, .08, -.04, -1.67, -.16, -.65,
                    -.09, .38, -.22, -.14, -.34, .37, .05) *
                    f0_2 +
                mat4(-.47, -.23, -.57, -.05, .51, .04, .00, .27, .80, .29,
                    -.09, -.53, -.20, -.41, -.64, -.12) *
                    f0_3 +
                vec4(1.08, 4.00, -2.54, 2.18)) /
            1.0 +
            f0_2;
    vec4 f1_3 = sin(mat4(-.30, .38, .39, .53, .73, .73, -.06, .01, .54, -.07,
                -.19, .68, .59, .40, .04, .07) *
                f0_0 +
                mat4(-.17, .44, -.61, .43, -.84, -.12, .65, -.50, .33, -.31,
                    -.28, .13, .18, -.42, .14, .08) *
                    f0_1 +
                mat4(-.78, .06, -.18, .37, -.99, .49, .71, .15, .27, -.48,
                    -.17, .25, .05, .10, -.40, -.21) *
                    f0_2 +
                mat4(-.17, -.27, .40, .18, -.24, .23, .03, -.83, -.30, -.38,
                    .07, .21, -.45, -.24, .78, .50) *
                    f0_3 +
                vec4(2.14, -3.48, 3.81, -1.43)) /
            1.0 +
            f0_3;
    vec4 f2_0 = sin(mat4(.83, .15, -.49, -.80, -.83, .16, 1.24, .75, -.27, .18,
                -.13, 1.05, .70, -.15, .30, .79) *
                f1_0 +
                mat4(-.38, -.17, .34, .67, -.39, .09, .48, -.93, .19, .60,
                    -.20, -.22, -.76, -.62, -.40, .01) *
                    f1_1 +
                mat4(.10, .22, .08, .13, -.42, -.11, .71, -.63, .02, .46,
                    -.07, -.46, -.37, .07, .15, .14) *
                    f1_2 +
                mat4(.09, -.48, -.38, .40, -.57, -.88, -.14, -.25, .20, .95,
                    .86, -1.08, .46, .04, .53, -.82) *
                    f1_3 +
                vec4(3.47, -3.66, 3.06, .84)) /
            1.4 +
            f1_0;
    vec4 f2_1 = sin(mat4(1.03, .03, -.76, -.03, .84, .66, -.49, .74, -.09, -.85,
                -.55, .17, .07, .85, -.55, -.20) *
                f1_0 +
                mat4(-.55, 1.13, .41, -.21, -.55, .19, .49, .67, .40, 1.80,
                    -.82, -.83, -1.02, .78, -.42, -.51) *
                    f1_1 +
                mat4(.77, -.88, .64, 1.10, -.49, 1.05, -.43, -.38, .66, -.63,
                    .02, .11, -.24, -.23, .49, -.65) *
                    f1_2 +
                mat4(-.66, 1.90, .02, -.48, .22, -.62, -.68, -.44, .52, -.57,
                    .16, -.61, -.03, -.02, -.88, -.23) *
                    f1_3 +
                vec4(.58, -3.00, -2.53, .14)) /
            1.4 +
            f1_1;
    vec4 f2_2 = sin(mat4(-.44, -.06, .30, -.37, .27, -.23, -.56, .15, .03, -.14,
                -.08, .72, .76, -.58, .55, .29) *
                f1_0 +
                mat4(.31, .23, .42, -.17, .37, -.05, .39, .46, -1.14, .32,
                    .06, -.28, .28, -.21, -.58, .62) *
                    f1_1 +
                mat4(.92, -.16, .86, -.09, -.12, .33, -.49, -.24, .29, -.19,
                    .95, -.40, -.87, .08, .08, -.71) *
                    f1_2 +
                mat4(-.45, .67, 1.07, -.14, -.56, .06, -.81, -.15, -.57, -.24,
                    -1.09, .69, -.44, -.32, -.00, -.07) *
                    f1_3 +
                vec4(-4.43, -1.86, -2.87, 1.45)) /
            1.4 +
            f1_2;
    vec4 f2_3 = sin(mat4(.58, .25, .01, -.54, .34, .56, .61, -.79, -.01, .05,
                -.57, -1.31, .74, .78, -.10, -.11) *
                f1_0 +
                mat4(-.03, -.48, -.24, .01, .10, .23, .22, -.05, .76, .29,
                    -.37, .02, .54, -.07, .27, .38) *
                    f1_1 +
                mat4(.31, -1.03, .24, .95, .80, .29, .43, .61, -.04, -.22,
                    -.06, -.52, -.46, .35, .07, -.07) *
                    f1_2 +
                mat4(.47, -.12, -.62, .06, .47, -.41, .53, -2.14, -.59, .16,
                    .74, -.58, .32, .66, -.30, -.18) *
                    f1_3 +
                vec4(-2.86, -3.27, -.55, 2.87)) /
            1.4 +
            f1_3;
    return dot(f2_0, vec4(-.08, .03, .07, -.03)) +
        dot(f2_1, vec4(-.03, -.02, -.06, -.07)) +
        dot(f2_2, vec4(.05, -.09, .03, .11)) +
        dot(f2_3, vec4(.03, .06, -.06, -.03)) + -0.014;
}

/////////////////////////////////////////////////////
//// Step 1: training a neural SDF model
//// You are asked to train your own neural SDF model on Colab.
//// Your implementation should take place in neural_sdf.ipynb.
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 2: copy neural SDF weights to GLSL
//// In this step, you are asked to the network weights you have trained from
/// the text file to the function sdfCow(). / You should replace the default
/// implementation (a sphere) with your own network weights.
/////////////////////////////////////////////////////

float sdfCow(vec3 p) {
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 3. + PI / 3.0);
    // p = rotate(p, vec3(0., 0., 1.), PI / 2. + PI / 1.0);

    // sdf is undefined outside the unit sphere, uncomment to witness the
    // abominations
    if (length(p) > 1.) {
        return length(p) - 0.9;
    }

    //// your implementation starts
vec4 f0_0=sin(p.y*vec4(3.02,-.90,1.46,-1.82)+p.z*vec4(3.84,3.57,-.17,.78)+p.x*vec4(2.65,-3.12,-1.57,1.20)+vec4(3.99,1.02,.01,-4.07));
vec4 f0_1=sin(p.y*vec4(-2.71,-1.72,-1.97,-2.54)+p.z*vec4(-1.48,-.06,-2.53,-2.59)+p.x*vec4(-1.72,-3.39,.98,-1.42)+vec4(-1.75,3.48,3.77,2.08));
vec4 f0_2=sin(p.y*vec4(1.84,4.20,-2.39,2.82)+p.z*vec4(4.70,.33,-1.82,-2.05)+p.x*vec4(-3.49,-4.41,-1.29,-.64)+vec4(3.83,-5.45,5.98,-5.14));
vec4 f0_3=sin(p.y*vec4(-1.69,2.43,-3.76,-2.09)+p.z*vec4(4.19,-1.07,1.03,-2.14)+p.x*vec4(-1.47,-4.09,-.94,3.29)+vec4(-.86,-5.74,3.85,-2.74));
vec4 f1_0=sin(mat4(.10,.04,.14,-.16,.05,-.34,-.17,.47,-1.10,-.48,-.38,-.30,-1.03,-.54,-.18,-.31)*f0_0+
    mat4(-.33,-.37,.16,-.01,-.17,.24,.37,.18,.58,-.12,-.67,.70,.71,.87,-.25,-.83)*f0_1+
    mat4(.11,-.01,-.90,-.30,.20,-.34,.06,-.39,.59,1.38,-.64,.17,.62,.52,.21,.43)*f0_2+
    mat4(.66,.08,-.76,-.09,-.29,-.06,-.05,-.30,-.97,-.87,-.39,.36,-.00,-.03,-.90,-.14)*f0_3+
    vec4(3.81,-3.87,4.10,3.35))/1.0+f0_0;
vec4 f1_1=sin(mat4(.03,.21,-.30,.24,.53,.15,.20,.25,-.66,-.88,-.56,-.72,.46,-.67,1.11,-1.04)*f0_0+
    mat4(-.07,-.00,-.15,-.29,-.52,-1.47,-.39,-.41,-.74,-.31,.31,.02,-.10,-.15,.74,.47)*f0_1+
    mat4(.19,-.37,.38,.34,-.14,.42,-.09,-.19,-.12,-.03,.51,.09,-.08,.42,-.48,.18)*f0_2+
    mat4(-.26,-.50,-.47,.03,-.31,-.35,.07,.58,-.10,-.10,.26,-.01,.25,.01,-.07,-.12)*f0_3+
    vec4(-1.32,-1.09,1.95,-2.02))/1.0+f0_1;
vec4 f1_2=sin(mat4(-.41,.04,.45,.11,-.16,-.80,-.62,.06,-.74,-.25,.40,.28,-.78,.76,-.55,.34)*f0_0+
    mat4(.71,-.17,-.45,-.29,.19,.59,.13,.09,-.33,-.75,.02,.16,-.52,-.16,-.31,.42)*f0_1+
    mat4(-.67,.30,-.34,.40,.41,.08,-.25,.54,-.63,1.02,-.07,.57,-.61,-.11,.00,-.24)*f0_2+
    mat4(-.10,.04,.43,-.31,.60,-.17,.84,-.51,-.20,.39,-.17,-.91,-.21,.76,-.57,-.25)*f0_3+
    vec4(-1.64,.23,-1.89,-.54))/1.0+f0_2;
vec4 f1_3=sin(mat4(-.38,-.31,.36,-.22,-.55,-.14,.24,-.33,-.50,.07,-.48,.74,-.79,.44,-.53,-.95)*f0_0+
    mat4(1.21,-.35,-.29,.67,-.74,.92,-1.20,-.42,-.71,.08,.20,-.17,-.00,-.48,.04,-.07)*f0_1+
    mat4(-.33,-.27,-.01,.05,.21,.40,-.06,-.21,-1.03,-.35,-1.16,-.07,-1.06,-.10,-.92,.14)*f0_2+
    mat4(.19,.39,.38,.01,-.34,.03,.22,.40,-.19,.48,.20,-.05,.24,.18,-.36,.77)*f0_3+
    vec4(3.39,-2.37,2.75,-2.27))/1.0+f0_3;
vec4 f2_0=sin(mat4(.22,-.15,.44,-1.06,-1.03,-.18,-1.16,.14,1.07,-.38,.65,-1.07,.68,.32,.31,-.72)*f1_0+
    mat4(-.50,-.05,.70,.50,.59,.20,-.43,-.52,1.15,-.56,-.53,.06,-.80,-.41,.39,-.23)*f1_1+
    mat4(-.78,-.18,-.22,.22,.45,.37,.43,-.12,1.02,-.14,.32,-.46,.08,-.20,-.55,.04)*f1_2+
    mat4(.52,.37,-.72,-.09,1.06,.27,-.70,.58,-.54,-.12,-.87,-.04,.43,1.03,.82,.23)*f1_3+
    vec4(-.20,2.61,1.53,.98))/1.4+f1_0;
vec4 f2_1=sin(mat4(.39,.28,.44,-.72,-.45,-.31,.42,.42,1.01,.09,-.07,.03,-.32,.63,-.16,-.57)*f1_0+
    mat4(.82,-.48,-.10,-1.10,-.33,.29,-.30,-.12,-.20,.83,-.04,.03,-.13,.45,.53,.32)*f1_1+
    mat4(.02,-.13,.15,.20,.61,-.18,-.26,-.44,-.69,.63,-.18,.72,-.19,-.63,.42,.28)*f1_2+
    mat4(1.16,.82,.21,-.41,.33,.48,.19,.57,-.62,.20,.15,.48,-1.29,-.93,1.05,-.64)*f1_3+
    vec4(-1.01,.68,2.13,-1.62))/1.4+f1_1;
vec4 f2_2=sin(mat4(.11,.49,.58,.55,-.30,.61,-.14,-.41,.44,.14,.03,-.25,-.40,.20,-.11,.13)*f1_0+
    mat4(-.76,.26,-.31,-.56,-.40,-.75,.49,.10,-1.33,-.45,.16,1.08,.40,-.36,.49,-.21)*f1_1+
    mat4(-.73,-.45,.40,-.00,.07,-.06,-.19,-.14,.48,-.70,-.35,.28,.42,.60,.92,.20)*f1_2+
    mat4(-1.20,.48,.47,.40,1.06,.55,-.49,.47,-.31,-.57,.12,-.29,.92,-.27,.01,-.49)*f1_3+
    vec4(.17,1.24,1.91,2.99))/1.4+f1_2;
vec4 f2_3=sin(mat4(-.62,-.49,-.11,-.19,-.44,-.18,-.39,-.17,.11,.56,-.34,-.21,.66,.12,-.53,-.23)*f1_0+
    mat4(-.66,1.08,-.18,.63,.58,-.30,-.38,.42,.29,-.13,-.33,.70,-.21,-.76,1.63,.01)*f1_1+
    mat4(.87,.10,.57,.59,-.70,-.14,-.11,-.14,1.14,-.15,-.91,.19,.20,.33,1.47,-.18)*f1_2+
    mat4(-.17,.14,-.57,-.07,.63,.58,1.36,.41,-.31,-.56,-.48,-.51,-1.00,1.28,.72,-.08)*f1_3+
    vec4(-1.76,.05,1.66,-1.15))/1.4+f1_3;
return dot(f2_0,vec4(-.02,.07,-.04,-.06))+
    dot(f2_1,vec4(-.02,.05,.09,.05))+
    dot(f2_2,vec4(.03,.04,.07,-.08))+
    dot(f2_3,vec4(-.02,-.04,-.01,-.08))+
    0.152;

}

float sdfPanda(vec3 p) {
    p = rotate(p, vec3(1., 0., 0.), PI / 2.);
    p = rotate(p, vec3(0., 0., 1.), PI / 1. + PI / 4.0);
    // p = rotate(p, vec3(0., 1., 0.), PI / 2.);

    // sdf is undefined outside the unit sphere, uncomment to witness the
    // abominations
    if (length(p) > 1.) {
        return length(p) - 0.9;
    }

    //// your implementation starts
vec4 f0_0=sin(p.y*vec4(3.46,-1.32,3.15,3.59)+p.z*vec4(.42,4.02,-3.24,3.52)+p.x*vec4(-3.98,-.78,2.13,1.59)+vec4(5.83,-5.61,-1.75,-8.45));
vec4 f0_1=sin(p.y*vec4(-4.06,-.02,.38,.21)+p.z*vec4(2.10,-.93,2.59,.04)+p.x*vec4(2.25,1.53,-1.04,-1.67)+vec4(1.12,2.34,-1.26,-7.50));
vec4 f0_2=sin(p.y*vec4(-.28,-3.03,2.18,-2.14)+p.z*vec4(-2.94,2.05,4.01,3.66)+p.x*vec4(2.90,-4.27,.57,.23)+vec4(-4.19,-4.34,-8.23,-1.61));
vec4 f0_3=sin(p.y*vec4(3.14,3.97,-2.02,-4.29)+p.z*vec4(-.19,-1.80,2.08,-.60)+p.x*vec4(1.61,3.21,1.27,3.87)+vec4(-5.20,-2.68,-5.70,7.54));
vec4 f1_0=sin(mat4(1.00,-.06,-.38,.53,-.10,-.70,.43,-.10,.45,-.02,-.45,-.03,-.27,-.10,.09,.25)*f0_0+
    mat4(.11,-.26,-.01,1.04,-.03,.12,-.33,.81,-.14,.76,-.44,-.35,-.57,-.02,-.61,-.05)*f0_1+
    mat4(.34,.69,.22,-.20,-.35,-.57,-.21,-.17,.06,.02,.50,-.12,.05,.19,.66,.54)*f0_2+
    mat4(.19,-.47,-1.29,-.28,-.67,-.60,-.39,-.37,.28,.65,-.59,-1.03,.09,.14,.26,.26)*f0_3+
    vec4(-2.88,-.04,2.87,-.64))/1.0+f0_0;
vec4 f1_1=sin(mat4(.04,.05,-.47,-.12,.21,.28,.29,-.13,-.12,-.02,.08,.04,.22,.27,-.29,-.12)*f0_0+
    mat4(-.15,.09,.45,.48,.59,-.46,.78,-.35,-.25,.02,-.11,.39,.91,.54,.24,-.02)*f0_1+
    mat4(-.60,.46,.38,.37,-.17,-.33,-.28,.20,.25,.38,-.36,.34,-.26,.33,.46,.16)*f0_2+
    mat4(-.39,.25,.41,.06,.16,-.28,-.19,-.25,-.70,-.37,-.04,-.31,-.65,.18,-.30,.26)*f0_3+
    vec4(-1.11,-2.38,-1.89,-1.19))/1.0+f0_1;
vec4 f1_2=sin(mat4(.04,-.10,.47,-.18,-.07,.55,.04,-.48,.42,-.31,-.21,-.31,-.27,.02,-.66,.20)*f0_0+
    mat4(-.07,-.37,.69,.66,-.69,-.49,.23,-.32,.66,.18,-.34,-.44,-.28,.25,-.47,.35)*f0_1+
    mat4(.53,-.25,.66,.36,-.03,-.64,.05,-.20,-.46,-.18,-.25,.54,.15,-.51,-.53,-.10)*f0_2+
    mat4(-.07,-.84,-.39,-.31,-.36,-.73,-.48,.66,-.43,-.08,-.04,-.38,.20,.63,.22,.21)*f0_3+
    vec4(-1.78,2.50,-1.49,-1.54))/1.0+f0_2;
vec4 f1_3=sin(mat4(-.21,.24,-.65,-.41,-.09,-.45,-.49,-.36,.70,.12,-.52,-.04,-.10,.27,-.10,-.30)*f0_0+
    mat4(-.35,.12,-.43,.10,.26,.39,-.78,-.15,.37,-.06,-.87,.02,.72,-.27,-1.13,-.55)*f0_1+
    mat4(-.09,.02,.09,-.30,.51,1.08,-.61,.00,-.01,-.65,.35,.58,-.86,.32,-.21,.27)*f0_2+
    mat4(-.57,.10,.19,-.64,.09,.82,-.11,-.06,.70,.18,-.45,-.45,-.29,1.14,-.33,.17)*f0_3+
    vec4(-3.15,2.52,-.32,-2.96))/1.0+f0_3;
vec4 f2_0=sin(mat4(-.07,.51,-.61,-.09,-.15,.06,-.80,-.05,.00,-.18,.60,.54,-.31,-.32,.07,.24)*f1_0+
    mat4(-.02,.67,-.48,-.32,.25,.70,-.27,-.29,-.56,.18,-.33,.35,-.38,.09,-.61,.02)*f1_1+
    mat4(-.09,.49,-.54,-.85,.03,.43,.19,.15,.77,.40,.18,.25,-.40,.03,.01,.32)*f1_2+
    mat4(-.70,-.18,-.75,-.31,-.11,-.06,-.61,.41,.73,-.39,.47,.04,-.40,.28,-.03,.01)*f1_3+
    vec4(-.06,-3.48,3.07,.85))/1.4+f1_0;
vec4 f2_1=sin(mat4(.30,-.01,.20,-.52,.43,-.82,-.42,.45,.00,-.67,.31,.22,-.15,-.48,-.78,.27)*f1_0+
    mat4(.25,-.79,.08,.30,-.16,.27,-.04,.59,.23,-.60,-.51,-.20,-.17,.45,-.33,.27)*f1_1+
    mat4(-.15,-.83,-1.37,-.38,.02,-.31,.08,-.52,.03,-.17,.40,-.21,.64,-.86,-.09,-.59)*f1_2+
    mat4(-.94,-.48,.35,.25,-.18,.06,-.39,.15,-.46,.13,.23,.27,.61,.54,-.27,.25)*f1_3+
    vec4(-1.29,-3.56,-.34,-1.84))/1.4+f1_1;
vec4 f2_2=sin(mat4(-.15,-.46,-.20,.33,-.49,.58,.39,.07,-.21,-.19,.22,-.01,-.05,.54,-.16,.49)*f1_0+
    mat4(-.32,-.32,.61,-.58,.55,-.05,-.10,-.70,-.07,.82,.45,.31,1.45,.64,.51,-.13)*f1_1+
    mat4(-.86,-.26,-.37,.38,-.36,-.29,-.17,-.35,.18,-.52,.45,-.66,.21,-.30,.62,.13)*f1_2+
    mat4(-.50,-.38,-.74,.32,.32,.56,.25,.75,-.27,-.53,-.15,-.26,-.06,.06,-.29,-.59)*f1_3+
    vec4(-1.05,-.31,-3.43,1.37))/1.4+f1_2;
vec4 f2_3=sin(mat4(-.37,.19,.28,.18,.40,.88,-.27,-.37,.65,.36,-.66,.22,-.78,-.80,-.52,.07)*f1_0+
    mat4(-1.55,.98,-.13,-.28,.22,.50,-.55,.43,-.50,-.23,-.61,-.15,.28,.36,-.14,.27)*f1_1+
    mat4(-.76,.23,-.78,.04,1.00,-.21,.44,-.49,.84,.38,.51,.64,-.04,.61,-.34,-.26)*f1_2+
    mat4(1.06,-.09,.68,.15,.55,.09,-.12,-.10,-.05,.54,-.06,.15,-.24,.55,-.31,-.06)*f1_3+
    vec4(.66,.03,-3.10,-.08))/1.4+f1_3;
return dot(f2_0,vec4(-.05,.06,-.05,.06))+
    dot(f2_1,vec4(-.07,.05,.03,-.05))+
    dot(f2_2,vec4(-.08,-.05,.06,-.04))+
    dot(f2_3,vec4(.02,-.04,-.06,-.09))+
    0.091;

}

vec2 sdfUnion(vec2 d1, vec2 d2) {
    return d1.x < d2.x ? d1 : d2;
}

float SphereSDF(vec3 p, vec3 center, float radius) {
    return length(p - center) - radius;
}

/////////////////////////////////////////////////////
//// Step 3: scene sdf
//// You are asked to use the sdf boolean operations to draw the bunny and the
/// cow in the scene. / The bunny is located in the ceter of vec3(-1.0, 1., 4.),
/// and the cow is located in the center of vec3(1.0, 1., 4.).
/////////////////////////////////////////////////////

//// sdf: p - query point
vec2 sdf(vec3 p) {
    vec2 s = vec2(0.);

    float plane_h = -0.1;

    //// calculate the sdf based on all objects in the scene

    //// your implementation starts
    s = vec2(sdfPlane(p, plane_h), 0);
    // s = sdfUnion(s, vec2(sdfBunny(p - vec3(-5.0, 1., 8.)), 1));
    // s = sdfUnion(s, vec2(sdfCow(p - vec3(0.0, 1., 8.)), 2));
    s = sdfUnion(s, vec2(sdfPanda(p - vec3(-1.0, 1., 6.)), 2));

    //// your implementation ends

    return s;
}

/////////////////////////////////////////////////////
//// ray marching
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 4: ray marching
//// You are asked to implement the ray marching algorithm within the following
/// for-loop. / You are allowed to reuse your previous implementation in A1a for
/// this function.
/////////////////////////////////////////////////////

//// ray marching: origin - ray origin; dir - ray direction
vec2 rayMarching(vec3 origin, vec3 dir) {
    // float s = 0.0;
    // vec2 s = vec2(0.);

    //// your implementation starts
    // int max_iter = 1000;
    int max_iter = 500;

    int iter = 0;
    float t = 0.0;
    while (iter < max_iter) {
        vec3 p = origin + t * dir;
        vec2 s = sdf(p);
        if (abs(s.x) < 0.00001) {
            return vec2(t, s.y);
        }
        t += s.x;
        iter++;
    }
    return vec2(t, 0.);
    //// your implementation ends

    // return s;
}

/////////////////////////////////////////////////////
//// normal calculation
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 5: normal calculation
//// You are asked to calculate the sdf normal based on finite difference.
//// You are allowed to reuse your previous implementation in A1a for this
/// function.
/////////////////////////////////////////////////////

//// normal: p - query point
vec3 normal(vec3 p) {
    // float s = sdf(p); //// sdf value in p
    float dx = 0.01; //// step size for finite difference

    //// your implementation starts
    vec3 diff = vec3(dx, 0.0, 0.0);
    vec3 n = normalize(vec3(sdf(p + diff.xyz).x - sdf(p - diff.xyz).x,
                sdf(p + diff.yxz).x - sdf(p - diff.yxz).x,
                sdf(p + diff.yzx).x - sdf(p - diff.yzx).x));
    //// your implementation ends

    return n;
}

/////////////////////////////////////////////////////
//// Phong shading
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//// Step 6: lighting and coloring
//// You are asked to specify the color for the two neural SDF objects in the
/// scene. / Each object must have a separate color without mixing. / Notice
/// that we have implemented the default Phong shading model for you.
/////////////////////////////////////////////////////

vec3 phong_shading(vec3 p, vec3 n, int id) {
    //// background
    if (p.z > 20.0) {
        vec3 color = vec3(0.04, 0.16, 0.33);
        return color;
    }

    //// phong shading
    vec3 lightPos = vec3(4. * sin(iTime), 4., 4. * cos(iTime));
    vec3 l = normalize(lightPos - p);
    float amb = 0.1;
    float dif = max(dot(n, l), 0.) * 0.7;
    vec3 eye = CAM_POS;
    float spec =
        pow(max(dot(reflect(-l, n), normalize(eye - p)), 0.0), 128.0) * 0.9;

    vec3 sunDir = normalize(vec3(0, 1, -1)); //// parallel light direction
    float sunDif = max(dot(n, sunDir), 0.) * 0.2;

    //// shadow
    // float s = rayMarching(p + n * 0.02, l);
    vec2 s = rayMarching(p + n * 0.02, l);
    if (s.x < length(lightPos - p))
        dif *= .2;

    vec3 color = vec3(1.0);

    //// your implementation starts

    if (id == 0) {
        color = vec3(1.0, 1.0, 1.0);
    } else if (id == 1) {
        color = vec3(1.0, 0.0, 0.0);
    } else if (id == 2) {
        color = vec3(0.0, 1.0, 0.0);
    }

    //// your implementation ends

    return (amb + dif + spec + sunDif) * color;
    // return (amb ) * color;
}

/////////////////////////////////////////////////////
//// main function
/////////////////////////////////////////////////////

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y; //// screen uv
    vec3 origin = CAM_POS; //// camera position
    vec3 dir = normalize(vec3(uv.x, uv.y, 1)); //// camera direction
    vec2 s = rayMarching(origin, dir); //// ray marching
    vec3 p = origin + dir * s.x; //// ray-sdf intersection
    vec3 n = normal(p); //// sdf normal
    vec3 color = phong_shading(p, n, int(s.y)); //// phong shading
    fragColor = vec4(color, 1.); //// fragment color
}

void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
}

